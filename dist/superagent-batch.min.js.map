{"version":3,"sources":["superagent-batch.min.js","/source/superagent-batch.js","/source/src/batch-response.js","/source/src/batched-response-parser.js","/source/src/batching-agent.js","/source/src/constants.js","/source/src/superagent-batch.js"],"names":["_toArray","arr","Array","isArray","from","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_slicedToArray","sliceIterator","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","get","call","getPrototypeOf","global","factory","exports","module","require","define","amd","superagentBatch","url","request","this","BatchResponse","req","parsedResponse","text","body","statusText","statusMessage","setStatusProperties","parseInt","status","header","headers","setHeaderProperties","method","parseBody","parseResponse","response","resp","replace","RegExp","httpVersion","respLines","split","newLine","_respLines$shift$split","shift","_respLines$shift$split2","message","slice","join","_respLines$shift$split3","_respLines$shift$split32","_name","content","toLowerCase","createBatchingAgent","containerRequest","batches","BatchingAgent","_request","apply","arguments","oldEnd","Request","end","endBatch","callback","requests","map","buildRequest","boundarySeparator","boundaryString","send","res","responses","parseBatchedResponse","forEach","_callback","_data","serializer","serialize","contentType","_serializedData","Response","separator","exec","filter","superagentResponses","_url$parse","parse","pathname","host","query","_query","window","location","keys","superagent","startBatch","set","superagent_batch"],"mappings":"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","file":"superagent-batch.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('url'), require('superagent')) :\n  typeof define === 'function' && define.amd ? define(['url', 'superagent'], factory) :\n  global.superagentBatch = factory(global.url, global.request)\n}(this, function (url, request) { 'use strict';\n\n  const boundaryString = '1439751438138';\n  const boundarySeparator = '--';\n  const newLine = '\\r\\n';\n  const httpVersion = 'HTTP/1.1';\n  const contentType = 'Content-Type';\n\n  function BatchResponse(req, parsedResponse) {\n    this.req = req;\n    this.text = parsedResponse.body;\n    this.statusText = parsedResponse.statusMessage;\n    this.setStatusProperties(parseInt(parsedResponse.status));\n    this.header = this.headers = parsedResponse.headers;\n    this.setHeaderProperties(this.header);\n    this.body = this.req.method != 'HEAD' ? this.parseBody(this.text) : null;\n  }\n\n  BatchResponse.prototype = request.Response.prototype;\n\n  function parseResponse(response) {\n    let parsedResponse = {};\n    let resp = response.replace(new RegExp('[^]*?' + httpVersion), httpVersion);\n    let respLines = resp.split(newLine);\n    let [version, status, ...message] = respLines.shift().split(' ');\n    parsedResponse.status = status;\n    parsedResponse.statusMessage = message.join(' ');\n    parsedResponse.headers = {};\n    while (respLines[0] !== '') {\n      let [name, content] = respLines.shift().split(': ');\n      parsedResponse.headers[name.toLowerCase()] = content;\n    }\n    respLines.shift();\n    parsedResponse.body = respLines.shift();\n    return parsedResponse;\n  }\n\n  var parseBatchedResponse = parseBatchedResponse = (batches, res) => {\n    let separator = '--' + /boundary=\"(.*)\"/.exec(res.header[contentType.toLowerCase()])[1];\n    let responses = res.text.split(separator).filter((resp) => resp.replace(newLine, '') !== boundarySeparator && resp.replace(newLine, '').length);\n    let superagentResponses = responses.map((resp, i) => {\n      let parsedResponse = parseResponse(resp);\n      return new BatchResponse(batches[i], parsedResponse);\n    });\n    return superagentResponses;\n  };\n\n  const buildRequest = (req) => {\n    let body = [];\n    const {pathname, host} = url.parse(req.url);\n    const query = req._query.length ? `?${req._query.join('&')}` : '';\n\n    body.push(boundarySeparator + boundaryString);\n    body.push('Content-Type: application/http; msgtype=request');\n\n    body.push('');\n\n    body.push(`${req.method} ${pathname}${query} ${httpVersion}`);\n\n    if (host === null && !window) {\n      throw ('Couldn\\'t determine host name for batched request');\n    }\n    body.push(`Host: ${host || window.location.host}`);\n\n    Object.keys(req.header).forEach((header) => body.push(`${header}: ${req.header[header]}`));\n\n    body.push('');\n\n    if (req._serializedData) {\n      body.push(req._serializedData);\n    }\n\n    body.push('');\n\n    return body.join(newLine);\n  };\n\n  function createBatchingAgent(containerRequest) {\n    let batches = [];\n\n    class BatchingAgent extends request {}\n\n    let oldEnd = BatchingAgent.Request.prototype.end;\n    BatchingAgent.endBatch = function(callback) {\n      BatchingAgent.Request.prototype.end = oldEnd;\n\n      let requests = batches.map((req) => buildRequest(req));\n      requests.push(boundarySeparator + boundaryString + boundarySeparator);\n\n      containerRequest.send(requests.join(newLine));\n      containerRequest.end((err, res) => {\n        let responses = parseBatchedResponse(batches, res);\n        responses.forEach((resp) => {\n          if (resp.req._callback) {\n            resp.req._callback(resp);\n          }\n        });\n        if (callback) {\n          callback(err, res);\n        }\n      });\n    };\n    BatchingAgent.Request.prototype.end = function end(callback) {\n      if (this._data) {\n        let serializer = BatchingAgent.serialize[this.header[contentType]];\n        if (this.header[contentType] && serializer) {\n          this._serializedData = serializer(this._data);\n        } else {\n          this._serializedData = this._data;\n        }\n      }\n      this._callback = callback;\n      batches.push(this);\n      return BatchingAgent;\n    };\n    return BatchingAgent;\n  }\n\n  const superagentBatch = function(superagent) {\n    superagent.Request.prototype.startBatch = function() {\n      this.set(contentType, `multipart/mixed; boundary=${boundaryString}`);\n      return createBatchingAgent(this);\n    };\n    return superagent;\n  };\n\n  var superagent_batch = superagentBatch;\n\n  return superagent_batch;\n\n}));\n","import request from 'superagent';\n\nexport default function BatchResponse(req, parsedResponse) {\n  this.req = req;\n  this.text = parsedResponse.body;\n  this.statusText = parsedResponse.statusMessage;\n  this.setStatusProperties(parseInt(parsedResponse.status));\n  this.header = this.headers = parsedResponse.headers;\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD' ? this.parseBody(this.text) : null;\n}\n\nBatchResponse.prototype = request.Response.prototype;\n","import {boundarySeparator, contentType, newLine, httpVersion} from './constants';\nimport BatchResponse from './batch-response.js';\n\nfunction parseResponse(response) {\n  let parsedResponse = {};\n  let resp = response.replace(new RegExp('[^]*?' + httpVersion), httpVersion);\n  let respLines = resp.split(newLine);\n  let [version, status, ...message] = respLines.shift().split(' ');\n  parsedResponse.status = status;\n  parsedResponse.statusMessage = message.join(' ');\n  parsedResponse.headers = {};\n  while (respLines[0] !== '') {\n    let [name, content] = respLines.shift().split(': ');\n    parsedResponse.headers[name.toLowerCase()] = content;\n  }\n  respLines.shift();\n  parsedResponse.body = respLines.shift();\n  return parsedResponse;\n}\n\nexport default parseBatchedResponse = (batches, res) => {\n  let separator = '--' + /boundary=\"(.*)\"/.exec(res.header[contentType.toLowerCase()])[1];\n  let responses = res.text.split(separator).filter((resp) => resp.replace(newLine, '') !== boundarySeparator && resp.replace(newLine, '').length);\n  let superagentResponses = responses.map((resp, i) => {\n    let parsedResponse = parseResponse(resp);\n    return new BatchResponse(batches[i], parsedResponse);\n  });\n  return superagentResponses;\n};\n","import {boundarySeparator, boundaryString, contentType, newLine, httpVersion} from './constants';\nimport parseBatchedResponse from 'batched-response-parser.js';\nimport request from 'superagent';\n\nconst buildRequest = (req) => {\n  let body = [];\n  const {pathname, host} = url.parse(req.url);\n  const query = req._query.length ? `?${req._query.join('&')}` : '';\n\n  body.push(boundarySeparator + boundaryString);\n  body.push('Content-Type: application/http; msgtype=request');\n\n  body.push('');\n\n  body.push(`${req.method} ${pathname}${query} ${httpVersion}`);\n\n  if (host === null && !window) {\n    throw ('Couldn\\'t determine host name for batched request');\n  }\n  body.push(`Host: ${host || window.location.host}`);\n\n  Object.keys(req.header).forEach((header) => body.push(`${header}: ${req.header[header]}`));\n\n  body.push('');\n\n  if (req._serializedData) {\n    body.push(req._serializedData);\n  }\n\n  body.push('');\n\n  return body.join(newLine);\n};\n\nexport default function createBatchingAgent(containerRequest) {\n  let batches = [];\n\n  class BatchingAgent extends request {}\n\n  let oldEnd = BatchingAgent.Request.prototype.end;\n  BatchingAgent.endBatch = function(callback) {\n    BatchingAgent.Request.prototype.end = oldEnd;\n\n    let requests = batches.map((req) => buildRequest(req));\n    requests.push(boundarySeparator + boundaryString + boundarySeparator);\n\n    containerRequest.send(requests.join(newLine));\n    containerRequest.end((err, res) => {\n      let responses = parseBatchedResponse(batches, res);\n      responses.forEach((resp) => {\n        if (resp.req._callback) {\n          resp.req._callback(resp);\n        }\n      });\n      if (callback) {\n        callback(err, res);\n      }\n    });\n  };\n  BatchingAgent.Request.prototype.end = function end(callback) {\n    if (this._data) {\n      let serializer = BatchingAgent.serialize[this.header[contentType]];\n      if (this.header[contentType] && serializer) {\n        this._serializedData = serializer(this._data);\n      } else {\n        this._serializedData = this._data;\n      }\n    }\n    this._callback = callback;\n    batches.push(this);\n    return BatchingAgent;\n  };\n  return BatchingAgent;\n}\n","export const boundaryString = '1439751438138';\nexport const boundarySeparator = '--';\nexport const newLine = '\\r\\n';\nexport const httpVersion = 'HTTP/1.1';\nexport const contentType = 'Content-Type';\n","import url from 'url';\nimport createBatchingAgent from './batching-agent';\nimport {boundaryString, contentType} from './constants.js';\n\nconst superagentBatch = function(superagent) {\n  superagent.Request.prototype.startBatch = function() {\n    this.set(contentType, `multipart/mixed; boundary=${boundaryString}`);\n    return createBatchingAgent(this);\n  };\n  return superagent;\n};\n\nexport default superagentBatch;\n"],"sourceRoot":"/source/"}