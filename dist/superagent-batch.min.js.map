{"version":3,"sources":["superagent-batch.min.js","/source/superagent-batch.js","/source/src/batch-response.js","/source/src/batched-response-parser.js","/source/src/batching-agent.js","/source/src/constants.js","/source/src/superagent-batch.js"],"names":["_toArray","arr","Array","isArray","from","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_slicedToArray","sliceIterator","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","get","call","getPrototypeOf","global","factory","exports","module","require","define","amd","superagentBatch","url","request","this","BatchResponse","req","parsedResponse","text","body","statusText","statusMessage","setStatusProperties","parseInt","status","header","headers","setHeaderProperties","method","parseBody","parseResponse","response","resp","replace","RegExp","httpVersion","respLines","split","newLine","_respLines$shift$split","shift","_respLines$shift$split2","message","slice","join","_respLines$shift$split3","_respLines$shift$split32","_name","content","toLowerCase","buildRequest","_url$parse","parse","pathname","host","query","_query","boundarySeparator","boundaryString","window","location","keys","forEach","_serializedData","createBatchingAgent","containerRequest","batches","BatchingAgent","_request","apply","arguments","oldEnd","Request","end","endBatch","callback","requests","map","send","res","responses","parseBatchedResponse","_callback","toError","_data","serializer","serialize","contentType","Response","separator","exec","filter","superagentResponses","superagent","startBatch","set","superagent_batch"],"mappings":"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","file":"superagent-batch.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('url'), require('superagent')) :\n  typeof define === 'function' && define.amd ? define(['url', 'superagent'], factory) :\n  global.superagentBatch = factory(global.url, global.request)\n}(this, function (url, request) { 'use strict';\n\n  const boundaryString = '1439751438138';\n  const boundarySeparator = '--';\n  const newLine = '\\r\\n';\n  const httpVersion = 'HTTP/1.1';\n  const contentType = 'Content-Type';\n\n  function BatchResponse(req, parsedResponse) {\n    this.req = req;\n    this.text = parsedResponse.body;\n    this.statusText = parsedResponse.statusMessage;\n    this.setStatusProperties(parseInt(parsedResponse.status));\n    this.header = this.headers = parsedResponse.headers;\n    this.setHeaderProperties(this.header);\n    this.body = this.req.method != 'HEAD' ? this.parseBody(this.text) : null;\n  }\n\n  BatchResponse.prototype = request.Response.prototype;\n\n  function parseResponse(response) {\n    let parsedResponse = {};\n    let resp = response.replace(new RegExp('[^]*?' + httpVersion), httpVersion);\n    let respLines = resp.split(newLine);\n    let [version, status, ...message] = respLines.shift().split(' ');\n    parsedResponse.status = status;\n    parsedResponse.statusMessage = message.join(' ');\n    parsedResponse.headers = {};\n\n    while (respLines[0] !== '') {\n      let [name, content] = respLines.shift().split(': ');\n      parsedResponse.headers[name.toLowerCase()] = content;\n    }\n\n    respLines.shift();\n    parsedResponse.body = respLines.shift();\n    return parsedResponse;\n  }\n\n  var parseBatchedResponse = parseBatchedResponse = (batches, res) => {\n    let separator = '--' + /boundary=\"(.*)\"/.exec(res.header[contentType.toLowerCase()])[1];\n    let responses = res.text.split(separator).filter((resp) => resp.replace(newLine, '') !== boundarySeparator && resp.replace(newLine, '').length);\n\n    let superagentResponses = responses.map((resp, i) => {\n      let parsedResponse = parseResponse(resp);\n      return new BatchResponse(batches[i], parsedResponse);\n    });\n\n    return superagentResponses;\n  };\n\n  function buildRequest(req) {\n    let body = [];\n    const {pathname, host} = url.parse(req.url);\n    const query = req._query.length ? `?${req._query.join('&')}` : '';\n\n    body.push(boundarySeparator + boundaryString);\n    body.push('Content-Type: application/http; msgtype=request');\n\n    body.push('');\n\n    body.push(`${req.method} ${pathname}${query} ${httpVersion}`);\n\n    if (host === null && !window) {\n      throw ('Couldn\\'t determine host name for batched request');\n    }\n\n    body.push(`Host: ${host || window.location.host}`);\n\n    Object.keys(req.header).forEach((header) => body.push(`${header}: ${req.header[header]}`));\n\n    body.push('');\n\n    if (req._serializedData) {\n      body.push(req._serializedData);\n    }\n\n    body.push('');\n\n    return body.join(newLine);\n  }\n\n  function createBatchingAgent(containerRequest) {\n    let batches = [];\n\n    class BatchingAgent extends request {}\n\n    let oldEnd = BatchingAgent.Request.prototype.end;\n    BatchingAgent.endBatch = function(callback) {\n      BatchingAgent.Request.prototype.end = oldEnd;\n\n      let requests = batches.map((req) => buildRequest(req));\n      requests.push(boundarySeparator + boundaryString + boundarySeparator);\n\n      containerRequest.send(requests.join(newLine));\n      containerRequest.end((err, res) => {\n        let responses = parseBatchedResponse(batches, res);\n        responses.forEach((resp) => {\n          if (resp.req._callback) {\n            resp.req._callback(resp.toError(), resp);\n          }\n        });\n\n        if (callback) {\n          callback(err, res);\n        }\n      });\n    };\n\n    BatchingAgent.Request.prototype.end = function end(callback) {\n      if (this._data) {\n        let serializer = BatchingAgent.serialize[this.header[contentType]];\n        if (this.header[contentType] && serializer) {\n          this._serializedData = serializer(this._data);\n        } else {\n          this._serializedData = this._data;\n        }\n      }\n\n      this._callback = callback;\n      batches.push(this);\n      return BatchingAgent;\n    };\n\n    return BatchingAgent;\n  }\n\n  const superagentBatch = function(superagent) {\n    superagent.Request.prototype.startBatch = function() {\n      this.set(contentType, `multipart/mixed; boundary=${boundaryString}`);\n      return createBatchingAgent(this);\n    };\n\n    return superagent;\n  };\n\n  var superagent_batch = superagentBatch;\n\n  return superagent_batch;\n\n}));\n","import request from 'superagent';\n\nexport default function BatchResponse(req, parsedResponse) {\n  this.req = req;\n  this.text = parsedResponse.body;\n  this.statusText = parsedResponse.statusMessage;\n  this.setStatusProperties(parseInt(parsedResponse.status));\n  this.header = this.headers = parsedResponse.headers;\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD' ? this.parseBody(this.text) : null;\n}\n\nBatchResponse.prototype = request.Response.prototype;\n","import {boundarySeparator, contentType, newLine, httpVersion} from './constants';\nimport BatchResponse from './batch-response.js';\n\nfunction parseResponse(response) {\n  let parsedResponse = {};\n  let resp = response.replace(new RegExp('[^]*?' + httpVersion), httpVersion);\n  let respLines = resp.split(newLine);\n  let [version, status, ...message] = respLines.shift().split(' ');\n  parsedResponse.status = status;\n  parsedResponse.statusMessage = message.join(' ');\n  parsedResponse.headers = {};\n\n  while (respLines[0] !== '') {\n    let [name, content] = respLines.shift().split(': ');\n    parsedResponse.headers[name.toLowerCase()] = content;\n  }\n\n  respLines.shift();\n  parsedResponse.body = respLines.shift();\n  return parsedResponse;\n}\n\nexport default parseBatchedResponse = (batches, res) => {\n  let separator = '--' + /boundary=\"(.*)\"/.exec(res.header[contentType.toLowerCase()])[1];\n  let responses = res.text.split(separator).filter((resp) => resp.replace(newLine, '') !== boundarySeparator && resp.replace(newLine, '').length);\n\n  let superagentResponses = responses.map((resp, i) => {\n    let parsedResponse = parseResponse(resp);\n    return new BatchResponse(batches[i], parsedResponse);\n  });\n\n  return superagentResponses;\n};\n","import url from 'url';\nimport {boundarySeparator, boundaryString, contentType, newLine, httpVersion} from './constants';\nimport parseBatchedResponse from 'batched-response-parser.js';\nimport request from 'superagent';\n\nfunction buildRequest(req) {\n  let body = [];\n  const {pathname, host} = url.parse(req.url);\n  const query = req._query.length ? `?${req._query.join('&')}` : '';\n\n  body.push(boundarySeparator + boundaryString);\n  body.push('Content-Type: application/http; msgtype=request');\n\n  body.push('');\n\n  body.push(`${req.method} ${pathname}${query} ${httpVersion}`);\n\n  if (host === null && !window) {\n    throw ('Couldn\\'t determine host name for batched request');\n  }\n\n  body.push(`Host: ${host || window.location.host}`);\n\n  Object.keys(req.header).forEach((header) => body.push(`${header}: ${req.header[header]}`));\n\n  body.push('');\n\n  if (req._serializedData) {\n    body.push(req._serializedData);\n  }\n\n  body.push('');\n\n  return body.join(newLine);\n}\n\nexport default function createBatchingAgent(containerRequest) {\n  let batches = [];\n\n  class BatchingAgent extends request {}\n\n  let oldEnd = BatchingAgent.Request.prototype.end;\n  BatchingAgent.endBatch = function(callback) {\n    BatchingAgent.Request.prototype.end = oldEnd;\n\n    let requests = batches.map((req) => buildRequest(req));\n    requests.push(boundarySeparator + boundaryString + boundarySeparator);\n\n    containerRequest.send(requests.join(newLine));\n    containerRequest.end((err, res) => {\n      let responses = parseBatchedResponse(batches, res);\n      responses.forEach((resp) => {\n        if (resp.req._callback) {\n          resp.req._callback(resp.toError(), resp);\n        }\n      });\n\n      if (callback) {\n        callback(err, res);\n      }\n    });\n  };\n\n  BatchingAgent.Request.prototype.end = function end(callback) {\n    if (this._data) {\n      let serializer = BatchingAgent.serialize[this.header[contentType]];\n      if (this.header[contentType] && serializer) {\n        this._serializedData = serializer(this._data);\n      } else {\n        this._serializedData = this._data;\n      }\n    }\n\n    this._callback = callback;\n    batches.push(this);\n    return BatchingAgent;\n  };\n\n  return BatchingAgent;\n}\n","export const boundaryString = '1439751438138';\nexport const boundarySeparator = '--';\nexport const newLine = '\\r\\n';\nexport const httpVersion = 'HTTP/1.1';\nexport const contentType = 'Content-Type';\n","import createBatchingAgent from './batching-agent';\nimport {boundaryString, contentType} from './constants.js';\n\nconst superagentBatch = function(superagent) {\n  superagent.Request.prototype.startBatch = function() {\n    this.set(contentType, `multipart/mixed; boundary=${boundaryString}`);\n    return createBatchingAgent(this);\n  };\n\n  return superagent;\n};\n\nexport default superagentBatch;\n"],"sourceRoot":"/source/"}